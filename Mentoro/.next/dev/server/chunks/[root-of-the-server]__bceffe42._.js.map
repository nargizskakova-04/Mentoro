{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/dilyarabaizova/Mentoro/Mentoro/src/lib/rag.ts"],"sourcesContent":["// RAG (Retrieval-Augmented Generation) - document processing and text extraction\n\nexport interface Chunk {\n    id: string;\n    text: string;\n    metadata: Record<string, unknown>;\n}\n\nconst mockStore: Chunk[] = [];\n\n/** Extract text from uploaded file (txt, md, PDF) */\nexport async function extractTextFromFile(file: File): Promise<string> {\n    const ext = (file.name.split('.').pop() || '').toLowerCase();\n\n    if (ext === 'txt' || ext === 'md') {\n        return await file.text();\n    }\n\n    if (ext === 'pdf') {\n        const { extractText } = await import('unpdf');\n        const arrayBuffer = await file.arrayBuffer();\n        const { text } = await extractText(new Uint8Array(arrayBuffer), { mergePages: true });\n        return text || '';\n    }\n\n    // doc, docx, xlsx - not fully supported\n    if (ext === 'doc' || ext === 'docx' || ext === 'xlsx') {\n        throw new Error(`File type .${ext} is not fully supported. Please use .txt, .md, or .pdf for best results.`);\n    }\n\n    return await file.text();\n}\n\nexport async function processDocument(file: File): Promise<{ sessionId: string; extractedText: string }> {\n    const text = await extractTextFromFile(file);\n    const cleanedText = text.trim() || 'No readable content found in the document.';\n\n    // Store chunks for RAG (simple sentence-based chunking)\n    const sentences = cleanedText\n        .split(/(?<=[.!?])\\s+/)\n        .filter((s) => s.trim().length > 20);\n    const chunkSize = 3;\n    for (let i = 0; i < sentences.length; i += chunkSize) {\n        const chunkText = sentences.slice(i, i + chunkSize).join(' ');\n        mockStore.push({\n            id: `${Date.now()}-${i}`,\n            text: chunkText,\n            metadata: { filename: file.name, index: i },\n        });\n    }\n\n    if (mockStore.length === 0) {\n        mockStore.push({\n            id: Date.now().toString(),\n            text: cleanedText,\n            metadata: { filename: file.name },\n        });\n    }\n\n    return { sessionId: 'session-' + Date.now(), extractedText: cleanedText };\n}\n\nexport function clearVectorStore(): void {\n    mockStore.length = 0;\n}\n\nexport async function retrieveRelevantChunks(query: string, limit = 5): Promise<Chunk[]> {\n    if (mockStore.length === 0) {\n        return [];\n    }\n    return mockStore.slice(0, limit);\n}\n"],"names":[],"mappings":"AAAA,iFAAiF;;;;;;;;;;;AAQjF,MAAM,YAAqB,EAAE;AAGtB,eAAe,oBAAoB,IAAU;IAChD,MAAM,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,EAAE,EAAE,WAAW;IAE1D,IAAI,QAAQ,SAAS,QAAQ,MAAM;QAC/B,OAAO,MAAM,KAAK,IAAI;IAC1B;IAEA,IAAI,QAAQ,OAAO;QACf,MAAM,EAAE,WAAW,EAAE,GAAG;QACxB,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,YAAY,IAAI,WAAW,cAAc;YAAE,YAAY;QAAK;QACnF,OAAO,QAAQ;IACnB;IAEA,wCAAwC;IACxC,IAAI,QAAQ,SAAS,QAAQ,UAAU,QAAQ,QAAQ;QACnD,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,IAAI,wEAAwE,CAAC;IAC/G;IAEA,OAAO,MAAM,KAAK,IAAI;AAC1B;AAEO,eAAe,gBAAgB,IAAU;IAC5C,MAAM,OAAO,MAAM,oBAAoB;IACvC,MAAM,cAAc,KAAK,IAAI,MAAM;IAEnC,wDAAwD;IACxD,MAAM,YAAY,YACb,KAAK,CAAC,iBACN,MAAM,CAAC,CAAC,IAAM,EAAE,IAAI,GAAG,MAAM,GAAG;IACrC,MAAM,YAAY;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,KAAK,UAAW;QAClD,MAAM,YAAY,UAAU,KAAK,CAAC,GAAG,IAAI,WAAW,IAAI,CAAC;QACzD,UAAU,IAAI,CAAC;YACX,IAAI,GAAG,KAAK,GAAG,GAAG,CAAC,EAAE,GAAG;YACxB,MAAM;YACN,UAAU;gBAAE,UAAU,KAAK,IAAI;gBAAE,OAAO;YAAE;QAC9C;IACJ;IAEA,IAAI,UAAU,MAAM,KAAK,GAAG;QACxB,UAAU,IAAI,CAAC;YACX,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB,MAAM;YACN,UAAU;gBAAE,UAAU,KAAK,IAAI;YAAC;QACpC;IACJ;IAEA,OAAO;QAAE,WAAW,aAAa,KAAK,GAAG;QAAI,eAAe;IAAY;AAC5E;AAEO,SAAS;IACZ,UAAU,MAAM,GAAG;AACvB;AAEO,eAAe,uBAAuB,KAAa,EAAE,QAAQ,CAAC;IACjE,IAAI,UAAU,MAAM,KAAK,GAAG;QACxB,OAAO,EAAE;IACb;IACA,OAAO,UAAU,KAAK,CAAC,GAAG;AAC9B"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///Users/dilyarabaizova/Mentoro/Mentoro/src/app/api/quizzes/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { processDocument, clearVectorStore } from '@/lib/rag';\n\nexport async function POST(request: NextRequest) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get('file') as File;\n\n        if (!file) {\n            return NextResponse.json({ error: 'No file provided' }, { status: 400 });\n        }\n\n        clearVectorStore();\n\n        const { sessionId, extractedText } = await processDocument(file);\n\n        return NextResponse.json({\n            success: true,\n            sessionId,\n            extractedText,\n            message: 'Document processed successfully',\n        });\n    } catch (error) {\n        console.error('Upload processing error details:', error);\n        return NextResponse.json({ error: 'Failed to process document', details: String(error) }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QAC1E;QAEA,IAAA,uIAAgB;QAEhB,MAAM,EAAE,SAAS,EAAE,aAAa,EAAE,GAAG,MAAM,IAAA,sIAAe,EAAC;QAE3D,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT;YACA;YACA,SAAS;QACb;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAA8B,SAAS,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IAC5G;AACJ"}}]
}